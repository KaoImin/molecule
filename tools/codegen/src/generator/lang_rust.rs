use std::io;

use case::CaseExt;
use proc_macro2 as m4;
use quote::quote;

use super::Generator;
use crate::{ast::verified as ast, VERSION};

const ATOM_NAME: &str = "u8";

impl Generator {
    pub(crate) fn generate_rust<W>(&self, writer: &mut W) -> io::Result<()>
    where
        W: io::Write,
    {
        writeln!(writer, "// Generated by Molecule {}", VERSION)?;
        writeln!(writer)?;
        let code = quote!(
            use molecule::prelude::{Entity as _, Reader as _};
            use molecule::faster_hex::hex_string;
        );
        write!(writer, "{}", code)?;
        writeln!(writer)?;
        for decl in &self.ast.decls[..] {
            match decl.typ {
                ast::TopDeclType::Option_(ref info) => {
                    gen_option(writer, &decl.name, info)?;
                }
                ast::TopDeclType::Union(ref info) => {
                    gen_union(writer, &decl.name, info)?;
                }
                ast::TopDeclType::Array(ref info) => {
                    gen_array(writer, &decl.name, info)?;
                }
                ast::TopDeclType::Struct(ref info) => {
                    gen_struct(writer, &decl.name, info)?;
                }
                ast::TopDeclType::FixedVector(ref info) => {
                    gen_fix_vec(writer, &decl.name, info)?;
                }
                ast::TopDeclType::DynamicVector(ref info) => {
                    gen_dyn_vec(writer, &decl.name, info)?;
                }
                ast::TopDeclType::Table(ref info) => {
                    gen_table(writer, &decl.name, info)?;
                }
                ast::TopDeclType::Atom => unreachable!(),
            };
        }
        Ok(())
    }
}

/*
 * Utilities
 */

fn ident_name(name: &str, suffix: &str) -> m4::Ident {
    let span = m4::Span::call_site();
    if name == ast::ATOM_NAME {
        m4::Ident::new(ATOM_NAME, span)
    } else {
        m4::Ident::new(&format!("{}{}", name, suffix).to_camel(), span)
    }
}

fn entity_name(name: &str) -> m4::Ident {
    ident_name(name, "")
}

fn reader_name(name: &str) -> m4::Ident {
    ident_name(name, "Reader")
}

fn entity_union_name(name: &str) -> m4::Ident {
    ident_name(name, "Union")
}

fn reader_union_name(name: &str) -> m4::Ident {
    ident_name(name, "UnionReader")
}

fn union_item_name(name: &str) -> m4::Ident {
    ident_name(name, "")
}

fn builder_name(name: &str) -> m4::Ident {
    ident_name(name, "Builder")
}

fn usize_lit(num: usize) -> m4::Literal {
    m4::Literal::usize_unsuffixed(num)
}

fn snake_name(name: &str) -> m4::Ident {
    let span = m4::Span::call_site();
    m4::Ident::new(&name.to_snake(), span)
}

fn entity_iterator_name(name: &str) -> m4::Ident {
    ident_name(name, "Iterator")
}

fn reader_iterator_name(name: &str) -> m4::Ident {
    ident_name(name, "ReaderIterator")
}

/*
 * Common
 */

fn def_entity_and_reader<W>(writer: &mut W, origin_name: &str) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let reader = reader_name(origin_name);
    let code = quote!(
        #[derive(Clone)]
        pub struct #entity(molecule::bytes::Bytes);
        #[derive(Clone, Copy)]
        pub struct #reader<'r>(&'r [u8]);

        impl ::std::fmt::Debug for #entity {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "{}(0x{})", Self::NAME, hex_string(self.as_slice()).unwrap())
            }
        }
        impl<'r> ::std::fmt::Debug for #reader<'r> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "{}(0x{})", Self::NAME, hex_string(self.as_slice()).unwrap())
            }
        }
    );
    write!(writer, "{}", code)
}

fn impl_display_for_entity_and_reader<W>(
    writer: &mut W,
    origin_name: &str,
    stmts: m4::TokenStream,
) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let reader = reader_name(origin_name);
    let code = quote!(
        impl ::std::fmt::Display for #entity {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                #stmts
            }
        }
        impl<'r> ::std::fmt::Display for #reader<'r> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                #stmts
            }
        }
    );
    write!(writer, "{}", code)
}

fn impl_default_for_entity<W>(writer: &mut W, origin_name: &str, content: Vec<u8>) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let bytes = content.into_iter().map(|b| usize_lit(b as usize));
    let code = quote!(
        impl ::std::default::Default for #entity {
            fn default() -> Self {
                let v: Vec<u8> = vec![#( #bytes, )*];
                #entity::new_unchecked(v.into())
            }
        }
    );
    write!(writer, "{}", code)
}

fn def_items_for_union<W>(writer: &mut W, origin_name: &str, info: &ast::Union) -> io::Result<()>
where
    W: io::Write,
{
    let entity_union = entity_union_name(origin_name);
    let reader_union = reader_union_name(origin_name);
    let entity_union_string = entity_union.to_string();
    let reader_union_string = reader_union.to_string();
    let (
        ref entity_inners,
        ref reader_inners,
        ref union_items,
        ref union_ids,
        ref entity_union_item_paths,
        ref reader_union_item_paths,
    ) = info.inner.iter().enumerate().fold(
        (
            Vec::with_capacity(info.inner.len()),
            Vec::with_capacity(info.inner.len()),
            Vec::with_capacity(info.inner.len()),
            Vec::with_capacity(info.inner.len()),
            Vec::with_capacity(info.inner.len()),
            Vec::with_capacity(info.inner.len()),
        ),
        |(
            mut entity_inners,
            mut reader_inners,
            mut union_items,
            mut union_ids,
            mut entity_union_item_paths,
            mut reader_union_item_paths,
        ),
         (index, inner)| {
            let entity_name = entity_name(&inner.typ.name);
            let reader_name = reader_name(&inner.typ.name);
            let item_name = union_item_name(&inner.typ.name);
            let item_id = usize_lit(index + 1);
            let entity_union_item_path = quote!(#entity_union::#item_name);
            let reader_union_item_path = quote!(#reader_union::#item_name);
            entity_inners.push(entity_name);
            reader_inners.push(reader_name);
            union_items.push(item_name);
            union_ids.push(item_id);
            entity_union_item_paths.push(entity_union_item_path);
            reader_union_item_paths.push(reader_union_item_path);
            (
                entity_inners,
                reader_inners,
                union_items,
                union_ids,
                entity_union_item_paths,
                reader_union_item_paths,
            )
        },
    );
    {
        let entity_default = {
            let inner = &info.inner[0];
            let item_name = union_item_name(&inner.typ.name);
            quote!(#item_name(::std::default::Default::default()))
        };
        let code = quote!(
            #[derive(Debug, Clone)]
            pub enum #entity_union {
                NotSet,
                #( #union_items(#entity_inners), )*
            }
            #[derive(Debug, Clone, Copy)]
            pub enum #reader_union<'r> {
                NotSet,
                #( #union_items(#reader_inners<'r>), )*
            }

            impl ::std::default::Default for #entity_union {
                fn default() -> Self {
                    #entity_union::#entity_default
                }
            }

            impl ::std::fmt::Display for #entity_union {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    match self {
                        #(
                            #entity_union_item_paths(ref item) => {
                                write!(f, "{}::{}({})", Self::NAME, #union_items::NAME, item)
                            }
                        )*
                        #entity_union::NotSet => { write!(f, "NotSet") }
                    }
                }
            }
            impl<'r> ::std::fmt::Display for #reader_union<'r> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    match self {
                        #(
                            #reader_union_item_paths(ref item) => {
                                write!(f, "{}::{}({})", Self::NAME, #union_items::NAME, item)
                            }
                        )*
                        #reader_union::NotSet => { write!(f, "NotSet") }
                    }
                }
            }

            impl #entity_union {
                pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    match self {
                        #( #entity_union_item_paths(ref item) => write!(f, "{}", item), )*
                        #entity_union::NotSet => { write!(f, "NotSet") }
                    }
                }
            }
            impl<'r> #reader_union<'r> {
                pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    match self {
                        #( #reader_union_item_paths(ref item) => write!(f, "{}", item), )*
                        #reader_union::NotSet => { write!(f, "NotSet") }
                    }
                }
            }
        );
        write!(writer, "{}", code)?;
    }
    let union_items_string = &union_items
        .iter()
        .map(|x| x.to_string())
        .collect::<Vec<_>>();
    for (item_name, entity_name) in union_items.iter().zip(entity_inners.iter()) {
        let code = quote!(
            impl ::std::convert::From<#entity_name> for #entity_union {
                fn from(item: #entity_name) -> Self {
                    #entity_union::#item_name(item)
                }
            }
        );
        write!(writer, "{}", code)?;
    }
    for (item_name, reader_name) in union_items.iter().zip(reader_inners.iter()) {
        let code = quote!(
            impl<'r> ::std::convert::From<#reader_name<'r>> for #reader_union<'r> {
                fn from(item: #reader_name<'r>) -> Self {
                    #reader_union::#item_name(item)
                }
            }
        );
        write!(writer, "{}", code)?;
    }
    {
        let code = quote!(
            impl #entity_union {
                pub const NAME: &'static str = #entity_union_string;
                pub fn as_bytes(&self) -> molecule::bytes::Bytes {
                    match self {
                        #( #entity_union_item_paths(item) => item.as_bytes(), )*
                        #entity_union::NotSet => Default::default(),
                    }
                }
                pub fn as_slice(&self) -> &[u8] {
                    match self {
                        #( #entity_union_item_paths(item) => item.as_slice(), )*
                        #entity_union::NotSet => &[],
                    }
                }
                pub fn item_id(&self) -> molecule::ItemId {
                    match self {
                        #( #entity_union_item_paths(_) => #union_ids, )*
                        #entity_union::NotSet => 0,
                    }
                }
                pub fn item_name(&self) -> &str {
                    match self {
                        #( #entity_union_item_paths(_) => #union_items_string, )*
                        #entity_union::NotSet => "NotSet",
                    }
                }
                pub fn as_reader<'r>(&'r self) -> #reader_union<'r> {
                    match self {
                        #( #entity_union_item_paths(item) => item.as_reader().into(), )*
                        #entity_union::NotSet => #reader_union::NotSet,
                    }
                }
            }
            impl<'r> #reader_union<'r> {
                pub const NAME: &'r str = #reader_union_string;
                pub fn as_slice(&self) -> &'r [u8] {
                    match self {
                        #( #reader_union_item_paths(item) => item.as_slice(), )*
                        #reader_union::NotSet => &[],
                    }
                }
                pub fn item_id(&self) -> molecule::ItemId {
                    match self {
                        #( #reader_union_item_paths(_) => #union_ids, )*
                        #reader_union::NotSet => 0,
                    }
                }
                pub fn item_name(&self) -> &str {
                    match self {
                        #( #reader_union_item_paths(_) => #union_items_string, )*
                        #reader_union::NotSet => "NotSet",
                    }
                }
            }
        );
        write!(writer, "{}", code)?;
    }
    Ok(())
}

fn impl_trait_entity<W>(
    writer: &mut W,
    origin_name: &str,
    funcs: Vec<m4::TokenStream>,
) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let reader = reader_name(origin_name);
    let builder = builder_name(origin_name);
    let code = quote!(
        impl molecule::prelude::Entity for #entity {
            type Builder = #builder;
            fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
                #entity(data)
            }
            fn as_bytes(&self) -> molecule::bytes::Bytes {
                self.0.clone()
            }
            fn as_slice(&self) -> &[u8] {
                &self.0[..]
            }
            fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
                #reader::from_slice(slice).map(|reader| reader.to_entity())
            }
            fn new_builder() -> Self::Builder {
                ::std::default::Default::default()
            }
            #( #funcs )*
        }
    );
    write!(writer, "{}", code)
}

fn impl_entity<W>(writer: &mut W, origin_name: &str, funcs: Vec<m4::TokenStream>) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let entity_string = entity.to_string();
    let reader = reader_name(origin_name);
    let code = quote!(
        impl #entity {
            pub const NAME: &'static str = #entity_string;
            pub fn as_reader<'r>(&'r self) -> #reader<'r> {
                #reader::new_unchecked(self.as_slice())
            }
            #( #funcs )*
        }
    );
    write!(writer, "{}", code)
}

fn impl_trait_reader<W>(writer: &mut W, origin_name: &str, funcs: m4::TokenStream) -> io::Result<()>
where
    W: io::Write,
{
    let entity = entity_name(origin_name);
    let reader = reader_name(origin_name);
    let code = quote!(
        impl<'r> molecule::prelude::Reader<'r> for #reader<'r> {
            type Entity = #entity;
            fn to_entity(&self) -> Self::Entity {
                #entity::new_unchecked(self.as_slice().into())
            }
            fn new_unchecked(slice: &'r [u8]) -> Self {
                #reader(slice)
            }
            fn as_slice(&self) -> &'r [u8] {
                self.0
            }
            #funcs
        }
    );
    write!(writer, "{}", code)
}

fn impl_reader<W>(writer: &mut W, origin_name: &str, funcs: Vec<m4::TokenStream>) -> io::Result<()>
where
    W: io::Write,
{
    let reader = reader_name(origin_name);
    let reader_string = reader.to_string();
    let code = quote!(
        impl<'r> #reader<'r> {
            pub const NAME: &'r str = #reader_string;
            #( #funcs )*
        }
    );
    write!(writer, "{}", code)
}

fn def_access_funcs_for_option(is_entity: bool, info: &ast::Option_) -> Vec<m4::TokenStream> {
    let (inner, getter_ret, getter_stmt) = if is_entity {
        let inner = entity_name(&info.typ.name);
        let getter_ret = quote!(#inner);
        let getter_stmt = quote!(self.0.clone());
        (inner, getter_ret, getter_stmt)
    } else {
        let inner = reader_name(&info.typ.name);
        let getter_ret = quote!(#inner<'r>);
        let getter_stmt = quote!(self.as_slice());
        (inner, getter_ret, getter_stmt)
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let code = quote!(
            pub fn is_none(&self) -> bool {
                self.0.is_empty()
            }

            pub fn is_some(&self) -> bool {
                !self.0.is_empty()
            }
        );
        funcs.push(code);
    }
    {
        let code = if info.typ.is_atom() {
            quote!(
                pub fn to_opt(&self) -> Option<#inner> {
                    if self.is_none() {
                        None
                    } else {
                        Some(self.0[0])
                    }
                }
            )
        } else {
            quote!(
                pub fn to_opt(&self) -> Option<#getter_ret> {
                    if self.is_none() {
                        None
                    } else {
                        Some(#inner::new_unchecked(#getter_stmt))
                    }
                }
            )
        };
        funcs.push(code);
    }
    funcs
}

fn def_access_funcs_for_union(
    is_entity: bool,
    origin_name: &str,
    info: &ast::Union,
) -> Vec<m4::TokenStream> {
    let (union_name, getter_ret, getter_stmt) = if is_entity {
        let union = entity_union_name(origin_name);
        let union_name = quote!(#union);
        let getter_ret = quote!(#union);
        let getter_stmt = quote!(self.0.slice_from(molecule::ITEM_ID_SIZE));
        (union_name, getter_ret, getter_stmt)
    } else {
        let union = reader_union_name(origin_name);
        let union_name = quote!(#union);
        let getter_ret = quote!(#union<'r>);
        let getter_stmt = quote!(&self.as_slice()[molecule::ITEM_ID_SIZE..]);
        (union_name, getter_ret, getter_stmt)
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let item_count = usize_lit(info.inner.len());
        let code = quote!(
            pub const ITEM_COUNT: usize = #item_count;

            pub fn item_id(&self) -> molecule::ItemId {
                molecule::extract_item_id(self.as_slice())
            }
        );
        funcs.push(code);
    }
    {
        let match_stmts = info.inner.iter().enumerate().map(|(index, inner)| {
            let item_id = usize_lit(index + 1);
            let inner = if is_entity {
                entity_name(&inner.typ.name)
            } else {
                reader_name(&inner.typ.name)
            };
            quote!(#item_id => #inner::new_unchecked(inner).into(),)
        });
        let code = quote!(
            pub fn to_enum(&self) -> #getter_ret {
                let inner = #getter_stmt;
                match self.item_id() {
                    #( #match_stmts )*
                    0 => #union_name::NotSet,
                    _ => unreachable!(),
                }
            }
        );
        funcs.push(code);
    }
    funcs
}

fn def_access_funcs_for_array(is_entity: bool, info: &ast::Array) -> Vec<m4::TokenStream> {
    let (inner, getter_ret, getter_ret_atom, getter_stmt_atom) = if is_entity {
        let inner = entity_name(&info.typ.name);
        let getter_ret = quote!(#inner);
        let getter_ret_atom = quote!(molecule::bytes::Bytes);
        let getter_stmt_atom = quote!(self.as_bytes());
        (inner, getter_ret, getter_ret_atom, getter_stmt_atom)
    } else {
        let inner = reader_name(&info.typ.name);
        let getter_ret = quote!(#inner<'r>);
        let getter_ret_atom = quote!(&'r [u8]);
        let getter_stmt_atom = quote!(self.as_slice());
        (inner, getter_ret, getter_ret_atom, getter_stmt_atom)
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let total_size = usize_lit(info.item_size * info.item_count);
        let item_size = usize_lit(info.item_size);
        let item_count = usize_lit(info.item_count);
        let code = quote!(
            pub const TOTAL_SIZE: usize = #total_size;
            pub const ITEM_SIZE: usize = #item_size;
            pub const ITEM_COUNT: usize = #item_count;
        );
        funcs.push(code);
    }
    if info.typ.is_atom() {
        let code = quote!(
            pub fn raw_data(&self) -> #getter_ret_atom {
                #getter_stmt_atom
            }
        );
        funcs.push(code);
    }
    for idx in 0..info.item_count {
        let start = usize_lit(idx * info.item_size);
        let func = snake_name(&format!("nth{}", idx));
        let code = if info.typ.is_atom() {
            quote!(
                pub fn #func(&self) -> #inner {
                    self.0[#start]
                }
            )
        } else {
            let end = usize_lit((idx + 1) * info.item_size);
            let getter_stmt = if is_entity {
                quote!(self.0.slice(#start, #end))
            } else {
                quote!(&self.as_slice()[#start..#end])
            };
            quote!(
                pub fn #func(&self) -> #getter_ret {
                    #inner::new_unchecked(#getter_stmt)
                }
            )
        };
        funcs.push(code);
    }
    funcs
}

fn def_access_funcs_for_struct(is_entity: bool, info: &ast::Struct) -> Vec<m4::TokenStream> {
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let total_size = usize_lit(info.field_size.iter().sum());
        let field_count = usize_lit(info.inner.len());
        let fields_size = info.field_size.iter().map(|x| usize_lit(*x as usize));
        let code = quote!(
            pub const TOTAL_SIZE: usize = #total_size;
            pub const FIELD_COUNT: usize = #field_count;
            pub const FIELDS_SIZE: [usize; #field_count]= [ #( #fields_size, )* ];
        );
        funcs.push(code);
    }
    {
        let mut offset = 0;
        for (f, s) in info.inner.iter().zip(info.field_size.iter()) {
            let func = snake_name(&f.name);
            let (inner, getter_ret) = if is_entity {
                let inner = entity_name(&f.typ.name);
                let getter_ret = quote!(#inner);
                (inner, getter_ret)
            } else {
                let inner = reader_name(&f.typ.name);
                let getter_ret = quote!(#inner<'r>);
                (inner, getter_ret)
            };
            let start = usize_lit(offset);
            offset += s;
            let code = if f.typ.is_atom() {
                quote!(
                    pub fn #func(&self) -> #inner {
                        self.0[#start]
                    }
                )
            } else {
                let end = usize_lit(offset);
                let getter_stmt = if is_entity {
                    quote!(self.0.slice(#start, #end))
                } else {
                    quote!(&self.as_slice()[#start..#end])
                };
                quote!(
                    pub fn #func(&self) -> #getter_ret {
                        #inner::new_unchecked(#getter_stmt)
                    }
                )
            };
            funcs.push(code);
        }
    }
    funcs
}

fn def_access_funcs_for_fix_vec(is_entity: bool, info: &ast::FixedVector) -> Vec<m4::TokenStream> {
    let (inner, getter_ret, getter_stmt, getter_ret_atom, getter_stmt_atom) = if is_entity {
        let inner = entity_name(&info.typ.name);
        let getter_ret = quote!(#inner);
        let getter_stmt = quote!(self.0.slice(start, end));
        let getter_ret_atom = quote!(molecule::bytes::Bytes);
        let getter_stmt_atom = quote!(self.0.slice_from(4));
        (
            inner,
            getter_ret,
            getter_stmt,
            getter_ret_atom,
            getter_stmt_atom,
        )
    } else {
        let inner = reader_name(&info.typ.name);
        let getter_ret = quote!(#inner<'r>);
        let getter_stmt = quote!(&self.as_slice()[start..end]);
        let getter_ret_atom = quote!(&'r [u8]);
        let getter_stmt_atom = quote!(&self.as_slice()[4..]);
        (
            inner,
            getter_ret,
            getter_stmt,
            getter_ret_atom,
            getter_stmt_atom,
        )
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    let item_size = usize_lit(info.item_size);
    {
        let code = quote!(
            pub const ITEM_SIZE: usize = #item_size;

            pub fn len(&self) -> usize {
                let le = self.as_slice().as_ptr() as *const u32;
                u32::from_le(unsafe { *le }) as usize
            }
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
        );
        funcs.push(code);
    }
    {
        let item_size = usize_lit(info.item_size);
        let code = if info.typ.is_atom() {
            quote!(
                pub fn raw_data(&self) -> #getter_ret_atom {
                    #getter_stmt_atom
                }
                pub fn get(&self, idx: usize) -> Option<#inner> {
                    if idx >= self.len() {
                        None
                    } else {
                        Some(self.get_unchecked(idx))
                    }
                }
                pub fn get_unchecked(&self, idx: usize) -> #inner {
                    self.0[4 + idx]
                }
            )
        } else {
            quote!(
                pub fn get(&self, idx: usize) -> Option<#getter_ret> {
                    if idx >= self.len() {
                        None
                    } else {
                        Some(self.get_unchecked(idx))
                    }
                }
                pub fn get_unchecked(&self, idx: usize) -> #getter_ret {
                    let start = 4 + idx * #item_size;
                    let end = start + #item_size;
                    #inner::new_unchecked(#getter_stmt)
                }
            )
        };
        funcs.push(code);
    }
    funcs
}

fn def_access_funcs_for_dyn_vec(
    is_entity: bool,
    info: &ast::DynamicVector,
) -> Vec<m4::TokenStream> {
    let (inner, getter_ret, getter_stmt_last, getter_stmt) = if is_entity {
        let inner = entity_name(&info.typ.name);
        let getter_ret = quote!(#inner);
        let getter_stmt_last = quote!(self.0.slice_from(start));
        let getter_stmt = quote!(self.0.slice(start, end));
        (inner, getter_ret, getter_stmt_last, getter_stmt)
    } else {
        let inner = reader_name(&info.typ.name);
        let getter_ret = quote!(#inner<'r>);
        let getter_stmt_last = quote!(&self.as_slice()[start..]);
        let getter_stmt = quote!(&self.as_slice()[start..end]);
        (inner, getter_ret, getter_stmt_last, getter_stmt)
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let code = quote!(
            pub fn offsets(&self) -> (usize, &[u32]) {
                let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
                let bytes_len = u32::from_le(ptr[0]) as usize;
                (bytes_len, &ptr[1..])
            }
        );
        funcs.push(code);
    }
    {
        let code = quote!(
            pub fn len(&self) -> usize {
                let (bytes_len, offsets) = self.offsets();
                if bytes_len == 4 {
                    0
                } else {
                    let first = u32::from_le(offsets[0]) as usize;
                    (first - 4) / 4
                }
            }
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
        );
        funcs.push(code);
    }
    {
        let code = quote!(
            pub fn get(&self, idx: usize) -> Option<#getter_ret> {
                let len = self.len();
                if idx >= len {
                    None
                } else {
                    Some(self.get_unchecked(idx))
                }
            }
            pub fn get_unchecked(&self, idx: usize) -> #getter_ret {
                let len = self.len();
                let (_, offsets) = self.offsets();
                let start = u32::from_le(offsets[idx]) as usize;
                if idx == len - 1 {
                    #inner::new_unchecked(#getter_stmt_last)
                } else {
                    let end = u32::from_le(offsets[idx+1]) as usize;
                    #inner::new_unchecked(#getter_stmt)
                }
            }
        );
        funcs.push(code);
    }
    funcs
}

fn def_access_funcs_for_table(is_entity: bool, info: &ast::Table) -> Vec<m4::TokenStream> {
    let (getter_stmt_last, getter_stmt) = if is_entity {
        let getter_stmt_last = quote!(self.0.slice_from(start));
        let getter_stmt = quote!(self.0.slice(start, end));
        (getter_stmt_last, getter_stmt)
    } else {
        let getter_stmt_last = quote!(&self.as_slice()[start..]);
        let getter_stmt = quote!(&self.as_slice()[start..end]);
        (getter_stmt_last, getter_stmt)
    };
    let mut funcs: Vec<m4::TokenStream> = Vec::new();
    {
        let field_count = usize_lit(info.inner.len());
        let code = quote!(pub const FIELD_COUNT: usize = #field_count;);
        funcs.push(code);
    }
    {
        let code = quote!(
            pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
                let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
                let bytes_len = u32::from_le(ptr[0]) as usize;
                let first = u32::from_le(ptr[1]) as usize;
                let count = (first - 4) / 4;
                (bytes_len, count, &ptr[1..])
            }
        );
        funcs.push(code);
    }
    {
        let field_count = usize_lit(info.inner.len());
        for (i, f) in info.inner.iter().enumerate() {
            let func = snake_name(&f.name);
            let (inner, getter_ret) = if is_entity {
                let inner = entity_name(&f.typ.name);
                let getter_ret = quote!(#inner);
                (inner, getter_ret)
            } else {
                let inner = reader_name(&f.typ.name);
                let getter_ret = quote!(#inner<'r>);
                (inner, getter_ret)
            };
            let start = usize_lit(i);
            let code = if f.typ.is_atom() {
                quote!(
                    pub fn #func(&self) -> #inner {
                        let (_, _, offsets) = Self::field_offsets(self);
                        let offset = u32::from_le(offsets[#start]) as usize;
                        self.0[offset]
                    }
                )
            } else if i == info.inner.len() - 1 {
                quote!(
                    pub fn #func(&self) -> #getter_ret {
                        let (_, count, offsets) = Self::field_offsets(self);
                        let start = u32::from_le(offsets[#start]) as usize;
                        if count == #field_count {
                            #inner::new_unchecked(#getter_stmt_last)
                        } else {
                            let end = u32::from_le(offsets[#start+1]) as usize;
                            #inner::new_unchecked(#getter_stmt)
                        }
                    }
                )
            } else {
                quote!(
                    pub fn #func(&self) -> #getter_ret {
                        let (_, _, offsets) = Self::field_offsets(self);
                        let start = u32::from_le(offsets[#start]) as usize;
                        let end = u32::from_le(offsets[#start+1]) as usize;
                        #inner::new_unchecked(#getter_stmt)
                    }
                )
            };
            funcs.push(code);
        }
    }
    funcs
}

fn def_builder_for_option<W>(
    writer: &mut W,
    origin_name: &str,
    info: &ast::Option_,
) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let inner = entity_name(&info.typ.name);
    let code = quote!(
        #[derive(Debug, Default)]
        pub struct #builder (pub(crate) Option<#inner>);
    );
    write!(writer, "{}", code)
}

fn def_builder_for_array<W>(writer: &mut W, origin_name: &str, info: &ast::Array) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let inner = entity_name(&info.typ.name);
    let item_count = usize_lit(info.item_count);
    let code = quote!(
        pub struct #builder (pub(crate) [#inner; #item_count]);

        impl ::std::fmt::Debug for #builder {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "{}({:?})", Self::NAME, &self.0[..])
            }
        }

    );
    write!(writer, "{}", code)?;
    let code = if info.typ.is_atom() {
        quote!(
            impl ::std::default::Default for #builder {
                fn default() -> Self {
                    #builder ([0; #item_count])
                }
            }
        )
    } else {
        let inner_array = (0..info.item_count)
            .map(|_| inner.clone())
            .collect::<Vec<_>>();
        quote!(
            impl ::std::default::Default for #builder {
                fn default() -> Self {
                    #builder([#(#inner_array::default(), )*])
                }
            }
        )
    };
    write!(writer, "{}", code)
}

fn def_builder_for_union<W>(writer: &mut W, origin_name: &str) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let entity_union = entity_union_name(origin_name);
    let code = quote!(
        #[derive(Debug, Default)]
        pub struct #builder (pub(crate) #entity_union);
    );
    write!(writer, "{}", code)
}

fn def_builder_for_struct_or_table<W>(
    writer: &mut W,
    origin_name: &str,
    inner: &[ast::FieldDecl],
) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let fields = inner.iter().map(|f| {
        let field_name = snake_name(&f.name);
        let field_type = entity_name(&f.typ.name);
        quote!(#field_name: #field_type,)
    });
    let code = quote!(
        #[derive(Debug, Default)]
        pub struct #builder { #( pub(crate) #fields )* }
    );
    write!(writer, "{}", code)
}

fn def_builder_for_vector<W>(writer: &mut W, origin_name: &str, inner_name: &str) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let inner = entity_name(&inner_name);
    let code = quote!(
        #[derive(Debug, Default)]
        pub struct #builder (pub(crate) Vec<#inner>);
    );
    write!(writer, "{}", code)
}

fn impl_trait_builder<W>(
    writer: &mut W,
    origin_name: &str,
    funcs: m4::TokenStream,
) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let entity = entity_name(origin_name);
    let code = quote!(
        impl molecule::prelude::Builder for #builder {
            type Entity = #entity;
            #funcs
            fn build(&self) -> Self::Entity {
                let mut inner = Vec::with_capacity(self.expected_length());
                self.write(&mut inner).expect("write vector should be ok");
                #entity::new_unchecked(inner.into())
            }
        }
    );
    write!(writer, "{}", code)
}

fn impl_builder<W>(writer: &mut W, origin_name: &str, funcs: Vec<m4::TokenStream>) -> io::Result<()>
where
    W: io::Write,
{
    let builder = builder_name(origin_name);
    let builder_string = builder.to_string();
    let code = quote!(
        impl #builder {
            pub const NAME: &'static str = #builder_string;
            #( #funcs )*
        }
    );
    write!(writer, "{}", code)
}

fn def_iterator_for_vector<W>(
    writer: &mut W,
    origin_name: &str,
    inner_name: &str,
    is_atom: bool,
) -> io::Result<()>
where
    W: io::Write,
{
    let entity_iterator = entity_iterator_name(origin_name);
    let entity = entity_name(origin_name);
    let entity_inner = entity_name(inner_name);
    let reader_iterator = reader_iterator_name(origin_name);
    let reader = reader_name(origin_name);
    let reader_inner = reader_name(inner_name);
    let code = quote!(
        pub struct #entity_iterator (#entity, usize, usize);
        impl ::std::iter::Iterator for #entity_iterator {
            type Item = #entity_inner;
            fn next(&mut self) -> Option<Self::Item> {
                if self.1 >= self.2 {
                    None
                } else {
                    let ret = self.0.get_unchecked(self.1);
                    self.1 += 1;
                    Some(ret)
                }
            }
        }
        impl ::std::iter::ExactSizeIterator for #entity_iterator {
            fn len(&self) -> usize {
                self.2 - self.1
            }
        }
        impl ::std::iter::IntoIterator for #entity {
            type Item = #entity_inner;
            type IntoIter = #entity_iterator;
            fn into_iter(self) -> Self::IntoIter {
                let len = self.len();
                #entity_iterator(self, 0, len)
            }
        }
    );
    write!(writer, "{}", code)?;
    if !is_atom {
        let code = quote!(
            impl<'r> #reader<'r> {
                pub fn iter<'t>(&'t self) -> #reader_iterator<'t, 'r> {
                    #reader_iterator(&self, 0, self.len())
                }
            }
            pub struct #reader_iterator<'t, 'r> (&'t #reader<'r>, usize, usize);
            impl<'t: 'r, 'r> ::std::iter::Iterator for #reader_iterator<'t, 'r> {
                type Item = #reader_inner<'t>;
                fn next(&mut self) -> Option<Self::Item> {
                    if self.1 >= self.2 {
                        None
                    } else {
                        let ret = self.0.get_unchecked(self.1);
                        self.1 += 1;
                        Some(ret)
                    }
                }
            }
            impl<'t: 'r, 'r> ::std::iter::ExactSizeIterator for #reader_iterator<'t, 'r> {
                fn len(&self) -> usize {
                    self.2 - self.1
                }
            }
        );
        write!(writer, "{}", code)?;
    }
    Ok(())
}

/*
 * Core
 */

fn gen_option<W>(writer: &mut W, origin_name: &str, info: &ast::Option_) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        quote!({
            if let Some(v) = self.to_opt() {
                write!(f, "{}(Some({}))", Self::NAME, v)
            } else {
                write!(f, "{}(None)", Self::NAME)
            }
        })
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_option(writer, origin_name, info)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder().set(self.to_opt())
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_option(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let inner = reader_name(&info.typ.name);
        if info.typ.is_atom() {
            quote!(
                fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                    use molecule::error::VerificationError;
                    if slice.len() > 1 {
                        let err = VerificationError::TotalSizeNotAsExpected(
                            Self::NAME.to_owned(),
                            0,
                            1,
                            slice.len(),
                        );
                        Err(err)?;
                    }
                    Ok(())
                }
            )
        } else {
            quote!(
                fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                    if !slice.is_empty() {
                        #inner::verify(&slice[..])?;
                    }
                    Ok(())
                }
            )
        }
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_option(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        let write_inner = if info.typ.is_atom() {
            quote!(if let Some(inner) = self.0 {
                writer.write_all(&[inner])
            } else {
                Ok(())
            })
        } else {
            quote!(if let Some(ref inner) = self.0 {
                writer.write_all(inner.as_slice())
            } else {
                Ok(())
            })
        };
        let expected_length = if info.typ.is_atom() {
            quote!(if let Some(_) = self.0 { 1 } else { 0 })
        } else {
            quote!(if let Some(ref inner) = self.0 {
                inner.as_slice().len()
            } else {
                0
            })
        };
        quote!(
            fn expected_length(&self) -> usize {
                #expected_length
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                #write_inner
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        let inner = entity_name(&info.typ.name);
        let code = quote!(
            pub fn set(mut self, v: Option<#inner>) -> Self {
                self.0 = v;
                self
            }
        );
        funcs.push(code);
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    writeln!(writer)
}

fn gen_union<W>(writer: &mut W, origin_name: &str, info: &ast::Union) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        quote!(
            write!(f, "{}(", Self::NAME)?;
            self.to_enum().display_inner(f)?;
            write!(f, ")")
        )
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_items_for_union(writer, origin_name, info)?;
    def_builder_for_union(writer, origin_name)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder().set(self.to_enum())
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_union(true, origin_name, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let item_count = usize_lit(info.inner.len());
        let verify_inners = info.inner.iter().enumerate().map(|(index, inner)| {
            let item_id = usize_lit(index + 1);
            let inner = reader_name(&inner.typ.name);
            quote!(#item_id => #inner::verify(&slice[molecule::ITEM_ID_SIZE..]),)
        });
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                if slice.len() < molecule::ITEM_ID_SIZE {
                    let err = VerificationError::HeaderIsBroken(
                        Self::NAME.to_owned(), molecule::ITEM_ID_SIZE, slice.len());
                    Err(err)?;
                }
                let item_id = molecule::extract_item_id(slice);
                match item_id {
                    #( #verify_inners )*
                    _ => {
                        let err = VerificationError::UnknownItem(
                            Self::NAME.to_owned(), #item_count, item_id);
                        Err(err)
                    },
                }?;
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_union(false, origin_name, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        quote!(
            fn expected_length(&self) -> usize {
                molecule::ITEM_ID_SIZE + self.0.as_slice().len()
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                let item_id = self.0.item_id().to_le_bytes();
                writer.write_all(&item_id[..])?;
                writer.write_all(self.0.as_slice())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let entity_union = entity_union_name(origin_name);
            let code = quote!(
                pub fn set<I>(mut self, v: I) -> Self
                where
                    I: ::std::convert::Into<#entity_union>
                {
                    self.0 = v.into();
                    self
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    writeln!(writer)
}

fn gen_array<W>(writer: &mut W, origin_name: &str, info: &ast::Array) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        if info.typ.is_atom() {
            quote!(write!(
                f,
                "{}(0x{})",
                Self::NAME,
                hex_string(&self.raw_data()).unwrap()
            ))
        } else {
            let display_items = (0..info.item_count).map(|idx| {
                let func = snake_name(&format!("nth{}", idx));
                if idx == 0 {
                    quote!(write!(f, "{}", self.#func())?;)
                } else {
                    quote!(write!(f, ", {}", self.#func())?;)
                }
            });
            quote!(
                write!(f, "{} [", Self::NAME)?;
                #( #display_items )*
                write!(f, "]")
            )
        }
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_array(writer, origin_name, info)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let items = (0..info.item_count)
                .map(|idx| snake_name(&format!("nth{}", idx)))
                .map(|func| quote!(self.#func()));
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder().set([ #( #items, )* ])
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_array(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let inner = reader_name(&info.typ.name);
        let total_size = usize_lit(info.item_size * info.item_count);
        let verify_inners = if info.typ.is_atom() {
            Vec::new()
        } else {
            (0..info.item_count)
                .map(|i| {
                    let start = usize_lit(info.item_size * i);
                    let end = usize_lit(info.item_size * (i + 1));
                    quote!(#inner::verify(&slice[#start..#end])?;)
                })
                .collect()
        };
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                if slice.len() != #total_size {
                    let err = VerificationError::TotalSizeNotMatch(
                        Self::NAME.to_owned(), #total_size, slice.len());
                    Err(err)?;
                }
                #( #verify_inners )*
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_array(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        let total_size = usize_lit(info.item_size * info.item_count);
        let write_inners = if info.typ.is_atom() {
            quote!(writer.write_all(&self.0)?;)
        } else {
            let idx = (0..info.item_count).map(usize_lit).collect::<Vec<_>>();
            quote!(#( writer.write_all(self.0[#idx].as_slice())?; )*)
        };
        quote!(
            fn expected_length(&self) -> usize {
                #total_size
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                #write_inners
                Ok(())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        let inner = entity_name(&info.typ.name);
        let item_count = usize_lit(info.item_count);
        {
            let code = quote!(
                pub fn set(mut self, v: [#inner; #item_count]) -> Self {
                    self.0 = v;
                    self
                }
            );
            funcs.push(code);
        }
        for idx in 0..info.item_count {
            let index = usize_lit(idx);
            let func = snake_name(&format!("nth{}", idx));
            let code = quote!(
                pub fn #func(mut self, v: #inner) -> Self {
                    self.0[#index] = v;
                    self
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    writeln!(writer)
}

fn gen_struct<W>(writer: &mut W, origin_name: &str, info: &ast::Struct) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        let display_fields = info.inner.iter().enumerate().map(|(i, f)| {
            let field = f.name.clone();
            let func = snake_name(&f.name);
            if i == 0 {
                quote!(write!(f, "{}: {}", #field, self.#func())?;)
            } else {
                quote!(write!(f, ", {}: {}", #field, self.#func())?;)
            }
        });
        quote!(
            write!(f, "{} {{ ", Self::NAME)?;
            #( #display_fields )*
            write!(f, " }}")
        )
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_struct_or_table(writer, origin_name, &info.inner[..])?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let fields = info.inner.iter().map(|f| snake_name(&f.name));
            let fields_func = fields.clone();
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder()
                        #( .#fields(self.#fields_func()) )*
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_struct(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let total_size = usize_lit(info.field_size.iter().sum());
        let verify_fields = {
            let mut offset = 0;
            let mut codes = Vec::with_capacity(info.field_size.len());
            for (f, s) in info.inner.iter().zip(info.field_size.iter()) {
                let field = reader_name(&f.typ.name);
                let start = usize_lit(offset);
                offset += s;
                let end = usize_lit(offset);
                if !f.typ.is_atom() {
                    let code = quote!(
                        #field::verify(&slice[#start..#end])?;
                    );
                    codes.push(code);
                }
            }
            codes
        };
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                if slice.len() != #total_size {
                    let err = VerificationError::TotalSizeNotMatch(
                        Self::NAME.to_owned(), #total_size, slice.len());
                    Err(err)?;
                }
                #( #verify_fields )*
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_struct(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        let total_size = usize_lit(info.field_size.iter().sum());
        let fields = info.inner.iter().map(|f| {
            let field_name = snake_name(&f.name);
            if f.typ.is_atom() {
                quote!(writer.write_all(&[self.#field_name])?;)
            } else {
                quote!(writer.write_all(self.#field_name.as_slice())?;)
            }
        });
        quote!(
            fn expected_length(&self) -> usize {
                #total_size
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                #( #fields )*
                Ok(())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        for f in info.inner.iter() {
            let field_name = snake_name(&f.name);
            let field_type = entity_name(&f.typ.name);
            let code = quote!(
                pub fn #field_name(mut self, v: #field_type) -> Self {
                    self.#field_name = v;
                    self
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    writeln!(writer)
}

fn gen_fix_vec<W>(writer: &mut W, origin_name: &str, info: &ast::FixedVector) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        if info.typ.is_atom() {
            quote!(write!(
                f,
                "{}(0x{})",
                Self::NAME,
                hex_string(&self.raw_data()).unwrap()
            ))
        } else {
            quote!(
                write!(f, "{} [", Self::NAME)?;
                for i in 0..self.len() {
                    if i == 0 {
                        write!(f, "{}", self.get_unchecked(i))?;
                    } else {
                        write!(f, ", {}", self.get_unchecked(i))?;
                    }
                }
                write!(f, "]")
            )
        }
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_vector(writer, origin_name, &info.typ.name)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder().extend(self.into_iter())
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_fix_vec(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let inner = reader_name(&info.typ.name);
        let item_size = usize_lit(info.item_size);
        let verify_inners = if info.typ.is_atom() {
            quote!()
        } else {
            quote!(
                for i in 0..item_count {
                    let start = #item_size * i;
                    let end = start + #item_size;
                    #inner::verify(&slice[start..end])?;
                }
            )
        };
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                let len = slice.len();
                if len < 4 {
                    let err =
                        VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
                    Err(err)?;
                }
                let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
                let item_count = u32::from_le(ptr[0]) as usize;
                let expected = 4 + #item_size * item_count;
                if len != expected {
                    let err = VerificationError::TotalSizeNotMatch(
                        Self::NAME.to_owned(),
                        expected,
                        len,
                    );
                    Err(err)?;
                }
                #verify_inners
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_fix_vec(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        let item_size = usize_lit(info.item_size);
        let write_inners = if info.typ.is_atom() {
            quote!(writer.write_all(&self.0)?;)
        } else {
            quote!(for inner in &self.0[..] {
                writer.write_all(inner.as_slice())?;
            })
        };
        quote!(
            fn expected_length(&self) -> usize {
                4 + #item_size * self.0.len()
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                let len = (self.0.len() as u32).to_le_bytes();
                writer.write_all(&len)?;
                #write_inners
                Ok(())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        let inner = entity_name(&info.typ.name);
        let code = quote!(
            pub fn set(mut self, v: Vec<#inner>) -> Self {
                self.0 = v;
                self
            }
            pub fn push(mut self, v: #inner) -> Self {
                self.0.push(v);
                self
            }
            pub fn extend<T: ::std::iter::IntoIterator<Item=#inner>>(mut self, iter: T) -> Self {
                for elem in iter {
                    self.0.push(elem);
                }
                self
            }
        );
        funcs.push(code);
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    def_iterator_for_vector(writer, origin_name, &info.typ.name, info.typ.is_atom())?;
    writeln!(writer)
}

fn gen_dyn_vec<W>(writer: &mut W, origin_name: &str, info: &ast::DynamicVector) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        quote!(
            write!(f, "{} [", Self::NAME)?;
            for i in 0..self.len() {
                if i == 0 {
                    write!(f, "{}", self.get_unchecked(i))?;
                } else {
                    write!(f, ", {}", self.get_unchecked(i))?;
                }
            }
            write!(f, "]")
        )
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_vector(writer, origin_name, &info.typ.name)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder().extend(self.into_iter())
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = def_access_funcs_for_dyn_vec(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let inner = reader_name(&info.typ.name);
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                let len = slice.len();
                if len < 4 {
                    let err = VerificationError::HeaderIsBroken(
                        Self::NAME.to_owned(), 4, len);
                    Err(err)?;
                }
                let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
                let total_size = u32::from_le(ptr[0]) as usize;
                if total_size != len {
                    let err = VerificationError::TotalSizeNotMatch(
                        Self::NAME.to_owned(), total_size, len);
                    Err(err)?;
                }
                if total_size == 4 {
                    return Ok(());
                }
                if total_size < 4 + 4 {
                    let err = VerificationError::DataIsShort(
                        Self::NAME.to_owned(), 8, total_size);
                    Err(err)?;
                }
                let offset_first = u32::from_le(ptr[1]) as usize;
                if offset_first % 4 != 0 {
                    let err = VerificationError::FirstOffsetIsBroken(
                        Self::NAME.to_owned(), offset_first);
                    Err(err)?;
                }
                if offset_first < 4 + 4 {
                    let err = VerificationError::FirstOffsetIsShort(
                        Self::NAME.to_owned(), 8, offset_first);
                    Err(err)?;
                }
                let item_count = offset_first / 4 - 1;
                let expected = 4 + 4 * item_count;
                if total_size < expected {
                    let err = VerificationError::DataIsShort(
                        Self::NAME.to_owned(), expected, total_size);
                    Err(err)?;
                }
                let mut offsets: Vec<usize> = ptr[1..(item_count+1)]
                    .iter()
                    .map(|x| u32::from_le(*x) as usize)
                    .collect();
                offsets.push(total_size);
                if offsets.windows(2).any(|i| i[0] > i[1]) {
                    let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
                    Err(err)?;
                }
                for i in 0..=(offsets.len()-2) {
                    let start = offsets[i];
                    let end = offsets[i+1];
                    #inner::verify(&slice[start..end])?;
                }
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_dyn_vec(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = {
        quote!(
            fn expected_length(&self) -> usize {
                let len_header = 4 + 4 * self.0.len();
                len_header + self.0.iter().map(|inner| inner.as_slice().len()).sum::<usize>()
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                let len = (self.expected_length() as u32).to_le_bytes();
                writer.write_all(&len[..])?;
                let mut offset = 4 + 4 * self.0.len();
                for inner in &self.0[..] {
                    let tmp = (offset as u32).to_le_bytes();
                    writer.write_all(&tmp[..])?;
                    offset += inner.as_slice().len();
                }
                for inner in &self.0[..] {
                    writer.write_all(inner.as_slice())?;
                }
                Ok(())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        let inner = entity_name(&info.typ.name);
        let code = quote!(
            pub fn set(mut self, v: Vec<#inner>) -> Self {
                self.0 = v;
                self
            }
            pub fn push(mut self, v: #inner) -> Self {
                self.0.push(v);
                self
            }
            pub fn extend<T: ::std::iter::IntoIterator<Item=#inner>>(mut self, iter: T) -> Self {
                for elem in iter {
                    self.0.push(elem);
                }
                self
            }
        );
        funcs.push(code);
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    def_iterator_for_vector(writer, origin_name, &info.typ.name, info.typ.is_atom())?;
    writeln!(writer)
}

fn gen_table<W>(writer: &mut W, origin_name: &str, info: &ast::Table) -> io::Result<()>
where
    W: io::Write,
{
    def_entity_and_reader(writer, origin_name)?;
    let stmts = {
        let display_fields = info.inner.iter().enumerate().map(|(i, f)| {
            let field = f.name.clone();
            let func = snake_name(&f.name);
            if i == 0 {
                quote!(write!(f, "{}: {}", #field, self.#func())?;)
            } else {
                quote!(write!(f, ", {}: {}", #field, self.#func())?;)
            }
        });
        let field_count = usize_lit(info.inner.len());
        let display_unresolved = if info.inner.is_empty() {
            quote!(write!(f, "..")?;)
        } else {
            quote!(write!(f, ", ..")?;)
        };
        quote!(
            write!(f, "{} {{ ", Self::NAME)?;
            #( #display_fields )*
            let (_, count, _) = Self::field_offsets(&self);
            if count != #field_count {
                #display_unresolved
            }
            write!(f, " }}")
        )
    };
    impl_display_for_entity_and_reader(writer, origin_name, stmts)?;
    def_builder_for_struct_or_table(writer, origin_name, &info.inner[..])?;
    impl_default_for_entity(writer, origin_name, info.default_content())?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        {
            let fields = info.inner.iter().map(|f| snake_name(&f.name));
            let fields_func = fields.clone();
            let code = quote!(
                fn as_builder(self) -> Self::Builder {
                    Self::new_builder()
                        #( .#fields(self.#fields_func()) )*
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_trait_entity(writer, origin_name, funcs)?;
    let funcs = def_access_funcs_for_table(true, info);
    impl_entity(writer, origin_name, funcs)?;
    let code = {
        let field_count = usize_lit(info.inner.len());
        let verify_fields = info.inner.iter().enumerate().map(|(i, f)| {
            let field = reader_name(&f.typ.name);
            let start = usize_lit(i);
            let end = usize_lit(i + 1);
            if f.typ.is_atom() {
                quote!(
                    if offsets[#start] + 1 != offsets[#end] {
                        let err = VerificationError::FieldIsBroken(
                            Self::NAME.to_owned(), #start);
                        Err(err)?;
                    }
                )
            } else {
                quote!(
                    #field::verify(&slice[offsets[#start]..offsets[#end]])?;
                )
            }
        });
        quote!(
            fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
                use molecule::error::VerificationError;
                let len = slice.len();
                if len < 4 {
                    let err = VerificationError::HeaderIsBroken(
                        Self::NAME.to_owned(), 4, len);
                    Err(err)?;
                }
                let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
                let total_size = u32::from_le(ptr[0]) as usize;
                if total_size != len {
                    let err = VerificationError::TotalSizeNotMatch(
                        Self::NAME.to_owned(), total_size, len);
                    Err(err)?;
                }
                if #field_count == 0 && total_size == 4 {
                    return Ok(());
                }
                let expected = 4 + 4 * #field_count;
                if total_size < expected {
                    let err = VerificationError::HeaderIsBroken(
                        Self::NAME.to_owned(), expected, total_size);
                    Err(err)?;
                }
                let mut offsets: Vec<usize> = ptr[1..=#field_count]
                    .iter()
                    .map(|x| u32::from_le(*x) as usize)
                    .collect();
                if offsets[0] != expected {
                    let err = VerificationError::FirstOffsetIsShort(
                        Self::NAME.to_owned(), expected, offsets[0]);
                    Err(err)?;
                }
                offsets.push(total_size);
                if offsets.windows(2).any(|i| i[0] > i[1]) {
                    let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
                    Err(err)?;
                }
                #( #verify_fields )*
                Ok(())
            }
        )
    };
    impl_trait_reader(writer, origin_name, code)?;
    let funcs = def_access_funcs_for_table(false, info);
    impl_reader(writer, origin_name, funcs)?;
    let code = if info.inner.is_empty() {
        quote!(
            fn expected_length(&self) -> usize {
                4
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                let len = 4u32.to_le_bytes();
                writer.write_all(&len[..])?;
                Ok(())
            }
        )
    } else {
        let mut fields: Vec<m4::TokenStream> = Vec::new();
        let mut lengths: Vec<m4::TokenStream> = Vec::new();
        let field_count = usize_lit(info.inner.len());
        for f in info.inner.iter() {
            let field_name = snake_name(&f.name);
            let code = if f.typ.is_atom() {
                quote!(writer.write_all(&[self.#field_name])?;)
            } else {
                quote!(writer.write_all(self.#field_name.as_slice())?;)
            };
            fields.push(code);
            let code = if f.typ.is_atom() {
                quote!(1)
            } else {
                quote!(self.#field_name.as_slice().len())
            };
            lengths.push(code);
        }
        let lengths1 = &lengths;
        let lengths2 = &lengths;
        quote!(
            fn expected_length(&self) -> usize {
                let len_header = 4 + #field_count * 4;
                len_header #(+ #lengths1)*
            }
            fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
                let len = (self.expected_length() as u32).to_le_bytes();
                writer.write_all(&len[..])?;
                let mut offset = 4 + #field_count * 4;
                #({
                    let tmp = (offset as u32).to_le_bytes();
                    writer.write_all(&tmp[..])?;
                    offset += #lengths2;
                })*
                let _ = offset;
                #( #fields )*
                Ok(())
            }
        )
    };
    impl_trait_builder(writer, origin_name, code)?;
    let funcs = {
        let mut funcs: Vec<m4::TokenStream> = Vec::new();
        for f in info.inner.iter() {
            let field_name = snake_name(&f.name);
            let field_type = entity_name(&f.typ.name);
            let code = quote!(
                pub fn #field_name(mut self, v: #field_type) -> Self {
                    self.#field_name = v;
                    self
                }
            );
            funcs.push(code);
        }
        funcs
    };
    impl_builder(writer, origin_name, funcs)?;
    writeln!(writer)
}
